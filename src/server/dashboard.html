<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP-TE</title>
    <link rel="icon" type="image/x-icon" href="/docs/flavicon.ico">
    <style>
        :root {
            /* Twilio primary palette */
            --primary: #F22F46;          /* Twilio red */
            --primary-dark: #D42B3F;     /* Darker shade of Twilio red */
            --primary-light: #F45C6D;    /* Lighter shade of Twilio red */
            --secondary: #121C2D;        /* Ink */
            --secondary-dark: #0A1018;   /* Darker shade of Ink */
            --secondary-light: #1E2D47;  /* Lighter shade of Ink */
            
            /* Twilio secondary colors */
            --sun: #FF7A00;             /* Sun */
            --bright-saffron: #FFCB44;  /* Bright Saffron */
            --sky: #51A9E3;             /* Sky */
            --mint: #6ADDB2;            /* Mint */
            
            /* Twilio grays */
            --gray-50: #F2F4F7;
            --gray-100: #D8DDE6;
            --gray-500: #7D8777;
            --gray-850: #1F2F36;
            
            /* Semantic colors */
            --success: #6ADDB2;          /* Using Mint as success */
            --warning: #FFCB44;          /* Using Bright Saffron as warning */
            --danger: #F22F46;           /* Using Twilio red as danger */
            --light: #FFFFFF;            /* White */
            --dark: #121C2D;             /* Using Ink as dark */
            
            /* Other UI colors */
            --gray: #D8DDE6;             /* Grey-100 */
            --gray-light: #F2F4F7;       /* Grey-50 */
            --gray-dark: #1F2F36;        /* Grey-850 */
            
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --radius: 0.375rem;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--light);
            color: var(--secondary);
            line-height: 1.5;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem 2rem;
            background-color: var(--secondary);
            color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .logo {
            height: 48px;
            width: auto;
            margin-right: 2rem;
            filter: brightness(1.1);
            transition: transform 0.2s ease;
        }

        .logo:hover {
            transform: scale(1.05);
        }

        .header-content {
            flex: 1;
            padding-left: 2rem;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
        }

        header h1 {
            color: var(--light);
            margin-bottom: 0.5rem;
            font-size: 1.75rem;
        }

        header p {
            color: var(--gray-100);
            opacity: 0.9;
            font-size: 1rem;
        }

        h1, h2, h3 {
            color: var(--secondary);
            font-weight: 700;
            transition: color 0.3s;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.5rem;
            margin: 1.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
        }

        .card {
            background-color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 4px solid var(--primary);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background-color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border-left: 4px solid var(--sky);
            transition: transform 0.2s;
        }

        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        .metric-title {
            font-weight: 600;
            color: var(--secondary);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.3s;
        }

        .metric-value {
            font-size: 1.1rem;
            margin: 0.5rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode {
            display: inline-block;
            width: 80px;
            font-weight: 500;
        }

        .metric-unit {
            font-size: 0.85rem;
            color: var(--gray-500);
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .model-section {
            margin-bottom: 2rem;
            background-color: white;
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: background-color 0.3s;
        }

        .model-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--secondary);
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
            transition: color 0.3s;
        }

        .model-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .compact-metric-card {
            background: linear-gradient(135deg, var(--light), var(--gray-50));
            border-radius: var(--radius);
            padding: 1rem;
            border: 1px solid var(--gray-100);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .compact-metric-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .compact-metric-title {
            font-weight: 600;
            color: var(--secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .compact-metric-content {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .compact-metric-label {
            color: var(--gray-500);
        }

        .compact-metric-value {
            text-align: right;
            font-weight: 500;
        }

        .run-counts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .run-counts-section {
            margin-bottom: 1.5rem;
        }

        .run-counts-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .run-counts-title::before {
            content: "üìä";
            font-size: 1.1rem;
        }

        .run-count-card {
            background: linear-gradient(135deg, var(--light), var(--gray-50));
            border-radius: var(--radius);
            padding: 0.75rem;
            border: 1px solid var(--gray-100);
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .run-count-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .run-count-title {
            font-size: 0.8rem;
            color: var(--gray-500);
            margin-bottom: 0.5rem;
        }

        .run-count-values {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            background-color: white;
            transition: background-color 0.3s;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            transition: background-color 0.3s;
        }

        th {
            background-color: var(--secondary);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:nth-child(even) {
            background-color: var(--gray-light);
        }

        tr:hover {
            background-color: rgba(242, 47, 70, 0.05);
        }

        td {
            border-bottom: 1px solid var(--gray-light);
        }

        .badge {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-control {
            background-color: var(--secondary);
            color: var(--light);
        }

        .badge-mcp {
            background-color: var(--primary);
            color: var(--light);
        }

        .success {
            color: var(--mint);
            font-weight: 600;
        }

        .failure {
            color: var(--danger);
            font-weight: 600;
        }

        .change-positive {
            color: var(--mint);
            font-weight: 600;
        }

        .change-negative {
            color: var(--danger);
            font-weight: 600;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            background-color: var(--primary);
            color: var(--light);
            border: none;
            border-radius: var(--radius);
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            background-color: var(--secondary-light);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--secondary);
            border: 1px solid var(--secondary);
        }

        .btn-outline:hover {
            background-color: var(--secondary);
            color: white;
        }

        .loading {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: var(--gray-dark);
        }

        .spinner {
            border: 3px solid var(--gray-light);
            border-radius: 50%;
            border-top: 3px solid var(--primary);
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .footer {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--gray);
            color: var(--gray-dark);
            text-align: center;
            font-size: 0.9rem;
        }

        /* Filters */
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-label {
            font-weight: 600;
            font-size: 0.9rem;
        }

        select {
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            border: 1px solid var(--gray);
            background-color: white;
            font-family: var(--font-sans);
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(242, 47, 70, 0.2);
        }

        /* Chart styles */
        .chart-container {
            height: 300px;
            margin-bottom: 2rem;
        }

        .chart-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        /* Task tabs */
        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--gray-100);
            gap: 0.5rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: var(--secondary);
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--primary);
            background-color: var(--gray-50);
            border-radius: var(--radius) var(--radius) 0 0;
        }

        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            background-color: var(--gray-50);
        }

        /* Warning Message */
        .card[style*="warning"] {
            border-left: 4px solid var(--warning);
            background-color: rgba(255, 203, 68, 0.1);
        }

        /* Statistics card */
        .stat-card {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-item {
            text-align: center;
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--light), var(--gray-50));
            border-radius: var(--radius);
            border: 1px solid var(--gray-100);
            transition: transform 0.2s;
        }

        .stat-item:hover {
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.75rem;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .metrics,
            .chart-row {
                grid-template-columns: 1fr;
            }
            
            .filters {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .stat-card {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.75rem;
            }
            
            h2 {
                font-size: 1.25rem;
            }
        }
    </style>
    <!-- Include Chart.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <a href="https://twilioalpha.com/" target="_blank" rel="noopener noreferrer">
                <img src="/docs/twilioAlphaLogo.png" alt="Twilio Alpha" class="logo">
            </a>
            <div class="header-content">
                <h1>Model Context Protocol Task Efficiency (MCP-TE) Benchmark</h1>
                <p>Compare the performance metrics of AI Coding Agents using default tools (Control) and those utilizing MCP implementations.</p>
            </div>
        </header>
        
        <div class="actions">
            <button id="refreshBtn" class="btn">
                <span>‚Üª</span> Refresh Data
            </button>
            <button id="downloadBtn" class="btn btn-secondary">
                <span>‚Üì</span> Download CSV
            </button>
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <span>Loading data...</span>
            </div>
        </div>
        
        <div class="filters">
            <div class="filter-group">
                <label class="filter-label" for="mcpServerFilter">MCP Server:</label>
                <select id="mcpServerFilter">
                    <option value="all">All Servers</option>
                    <!-- Will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="mcpClientFilter">MCP Client:</label>
                <select id="mcpClientFilter">
                    <option value="all">All Clients</option>
                    <!-- Will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="modelFilter">Model:</label>
                <select id="modelFilter">
                    <option value="all">All Models</option>
                    <!-- Will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="taskFilter">Task:</label>
                <select id="taskFilter">
                    <option value="all">All Tasks</option>
                    <option value="1">Task 1</option>
                    <option value="2">Task 2</option>
                    <option value="3">Task 3</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="modeFilter">Mode:</label>
                <select id="modeFilter">
                    <option value="all">All Modes</option>
                    <option value="control">Control</option>
                    <option value="mcp">MCP</option>
                </select>
            </div>
        </div>
        
        <!-- Test Approaches -->
        <div class="card">
            <h2>Test Approach</h2>
            <div class="metrics" style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Full-width box -->
                <div class="metric-card" style="width: 100%;">
                    <div class="metric-title">Testing Environment & Methodology</div>
                    <p>Tests are conducted using Cursor IDE in "Yolo" mode, allowing AI agents to execute actions autonomously. Task duration is automatically tracked by the system, while API calls, user interactions, and success status are manually counted according to the methodology documented in our <a href="https://github.com/nmogil-tw/mcp-te-benchmark" target="_blank" style="color: var(--primary);">GitHub repository</a>.</p>
                    <p style="margin-top: 10px">Each task is performed twice - once using traditional methods and once using MCP. The results are stored in summary.json which serves as the single source of truth for this dashboard.</p>
                </div>
                <!-- Two side-by-side boxes container -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="metric-card">
                        <div class="metric-title">
                            <span class="badge badge-control">Control</span>
                        </div>
                        <p>Traditional method using web search and terminal capabilities to complete API tasks. The Control approach requires manually looking up documentation and writing code from scratch.</p>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">
                            <span class="badge badge-mcp">MCP</span>
                        </div>
                        <p>Model Context Protocol approach that provides AI coding agents with direct access to API functions. MCP enables AI to understand API structure without external documentation.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Task Description -->
        <div class="card">
            <h2>Task Description</h2>
            <div class="tabs" id="taskTabs">
                <div class="tab active" data-task="1">Task 1</div>
                <div class="tab" data-task="2">Task 2</div>
                <div class="tab" data-task="3">Task 3</div>
            </div>
            <div class="task-content" id="task-1">
                <div class="metric-card">
                    <div class="metric-title">Task 1: Purchase a Canadian Phone Number</div>
                    <p>Search for and purchase an available Canadian phone number (preferably with area code 416).</p>
                </div>
            </div>
            <div class="task-content" id="task-2" style="display: none;">
                <div class="metric-card">
                    <div class="metric-title">Task 2: Create a Task Router Activity</div>
                    <p>Create a new Task Router activity named "Bathroom", this already exists so the Agent won't be able to create it.</p>
                </div>
            </div>
            <div class="task-content" id="task-3" style="display: none;">
                <div class="metric-card">
                    <div class="metric-title">Task 3: Create a Queue with Task Filter</div>
                    <p>Create a queue with a task filter that prevents routing tasks to workers in the "Bathroom" activity.</p>
                </div>
            </div>
        </div>
        
        <!-- Warning Message -->
        <div class="card" style="border-left: 4px solid var(--warning); background-color: rgba(236, 201, 75, 0.1);">
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                <h3 style="margin: 0; color: var(--secondary-dark);">Known Issue</h3>
            </div>
            <p style="margin-top: 0.5rem;">There is an open bug in Cursor which restricts MCP use to the "auto" Agent model, preventing us from selecting a specific LLM model. This limitation affects model-specific performance analysis.</p>
        </div>
        
        <!-- Overall Stats -->
        <div class="card">
            <h2>Overall Performance</h2>
            <div class="stat-card">
                <div class="stat-item">
                    <div id="improvementTime" class="stat-value">--%</div>
                    <div class="stat-label">Time Improvement</div>
                </div>
                <div class="stat-item">
                    <div id="improvementCalls" class="stat-value">--%</div>
                    <div class="stat-label">API Calls Reduction</div>
                </div>
                <div class="stat-item">
                    <div id="improvementInteractions" class="stat-value">--%</div>
                    <div class="stat-label">Interaction Reduction</div>
                </div>
                <div class="stat-item">
                    <div id="improvementSuccess" class="stat-value">--%</div>
                    <div class="stat-label">Success Rate Improvement</div>
                </div>
            </div>
            <div id="summary" class="metrics"></div>
        </div>
        
        <!-- Charts -->
        <div class="card">
            <h2>Performance Charts</h2>
            <div class="tabs">
                <div class="tab active" data-chart="duration">Duration</div>
                <div class="tab" data-chart="apiCalls">API Calls</div>
                <div class="tab" data-chart="interactions">Interactions</div>
                <div class="tab" data-chart="success">Success Rate</div>
            </div>
            <div class="chart-row">
                <div class="chart-container">
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="modelMetrics"></div>
        
        <div class="card">
            <h2>Detailed Results</h2>
            <div class="table-container">
                <table id="sessionsTable">
                    <thead>
                        <tr>
                            <th>MCP Server</th>
                            <th>MCP Client</th>
                            <th>Task</th>
                            <th>Mode</th>
                            <th>Model</th>
                            <th>Duration (s)</th>
                            <th>API Calls (count)</th>
                            <th>User Interactions (count)</th>
                            <th>Success</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody id="sessionsBody"></tbody>
                </table>
            </div>
        </div>
        
        <div class="footer">
            <p>Model Context Protocol Performance Dashboard</p>
            <p>Last updated: <span id="lastUpdated">-</span></p>
        </div>
    </div>

    <script>
        // Global data store
        let allSessions = [];
        let filteredSessions = [];
        let charts = {};
        
        async function loadData() {
            try {
                const response = await fetch('/metrics/summary.json');
                const data = await response.json();
                
                // Store the data globally
                allSessions = data;
                
                // Update last updated time
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                
                // Populate MCP server filter
                const mcpServers = [...new Set(data.map(s => s.mcpServer || 'Unknown'))];
                const mcpServerFilter = document.getElementById('mcpServerFilter');
                populateFilter(mcpServerFilter, mcpServers);
                
                // Populate MCP client filter
                const mcpClients = [...new Set(data.map(s => s.mcpClient || 'Unknown'))];
                const mcpClientFilter = document.getElementById('mcpClientFilter');
                populateFilter(mcpClientFilter, mcpClients);
                
                // Populate model filter
                const models = [...new Set(data.map(s => s.model || 'Unknown'))];
                const modelFilter = document.getElementById('modelFilter');
                populateFilter(modelFilter, models);
                
                // Apply filters and update UI
                filterData();
                displayMetrics();
                displayModelMetrics();
                displaySessions();
                initCharts();
                updateCharts();
                
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Failed to load data from summary.json. Please check if the file exists and is accessible.');
            }
        }

        function populateFilter(selectElement, options) {
            // Clear existing options except the first one (All)
            while (selectElement.options.length > 1) {
                selectElement.remove(1);
            }
            
            // Add new options
            options.sort().forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                selectElement.appendChild(optionElement);
            });
        }

        function filterData() {
            const mcpServerFilter = document.getElementById('mcpServerFilter').value;
            const mcpClientFilter = document.getElementById('mcpClientFilter').value;
            const modelFilter = document.getElementById('modelFilter').value;
            const taskFilter = document.getElementById('taskFilter').value;
            const modeFilter = document.getElementById('modeFilter').value;
            
            filteredSessions = allSessions.filter(session => {
                const matchesMcpServer = mcpServerFilter === 'all' || (session.mcpServer || 'Unknown') === mcpServerFilter;
                const matchesMcpClient = mcpClientFilter === 'all' || (session.mcpClient || 'Unknown') === mcpClientFilter;
                const matchesModel = modelFilter === 'all' || session.model === modelFilter || (!session.model && modelFilter === 'unknown');
                const matchesTask = taskFilter === 'all' || session.taskId.toString() === taskFilter;
                const matchesMode = modeFilter === 'all' || session.mode === modeFilter;
                
                return matchesMcpServer && matchesMcpClient && matchesModel && matchesTask && matchesMode;
            });
        }

        function displayMetrics() {
            const controlSessions = filteredSessions.filter(s => s.mode === 'control');
            const mcpSessions = filteredSessions.filter(s => s.mode === 'mcp');
            
            if (controlSessions.length === 0 || mcpSessions.length === 0) {
                document.getElementById('summary').innerHTML = '<p>No data available for the selected filters.</p>';
                return;
            }
            
            const metrics = {
                'Average Duration': {
                    control: average(controlSessions.map(s => s.duration)) / 1000, // Convert to seconds
                    mcp: average(mcpSessions.map(s => s.duration)) / 1000,
                    unit: 'seconds'
                },
                'Average API Calls': {
                    control: average(controlSessions.map(s => s.apiCalls)),
                    mcp: average(mcpSessions.map(s => s.apiCalls)),
                    unit: 'calls'
                },
                'Average Interactions': {
                    control: average(controlSessions.map(s => s.interactions)),
                    mcp: average(mcpSessions.map(s => s.interactions)),
                    unit: 'messages'
                },
                'Success Rate': {
                    control: percentage(controlSessions.filter(s => s.success).length, controlSessions.length),
                    mcp: percentage(mcpSessions.filter(s => s.success).length, mcpSessions.length),
                    unit: '%'
                }
            };
            
            // Update improvement stats
            const improvements = {
                time: percentageChange(metrics['Average Duration'].mcp, metrics['Average Duration'].control),
                calls: percentageChange(metrics['Average API Calls'].mcp, metrics['Average API Calls'].control),
                interactions: percentageChange(metrics['Average Interactions'].mcp, metrics['Average Interactions'].control),
                success: percentageChange(metrics['Success Rate'].mcp, metrics['Success Rate'].control)
            };
            
            document.getElementById('improvementTime').textContent = `${-parseFloat(improvements.time)}%`;
            document.getElementById('improvementCalls').textContent = `${-parseFloat(improvements.calls)}%`;
            document.getElementById('improvementInteractions').textContent = `${-parseFloat(improvements.interactions)}%`;
            document.getElementById('improvementSuccess').textContent = `${improvements.success}%`;

            const summaryEl = document.getElementById('summary');
            summaryEl.innerHTML = Object.entries(metrics)
                .map(([title, values]) => {
                    const change = percentageChange(values.mcp, values.control);
                    const changeClass = (title === 'Success Rate' ? 
                        parseFloat(change) > 0 : parseFloat(change) < 0) 
                        ? 'change-positive' : 'change-negative';
                    
                    return `
                        <div class="metric-card">
                            <div class="metric-title">${title}</div>
                            <div class="metric-unit">Measured in ${values.unit}</div>
                            <div class="metric-value">
                                <span class="mode">Control:</span>
                                <span>${values.control.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                            </div>
                            <div class="metric-value">
                                <span class="mode">MCP:</span>
                                <span>${values.mcp.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                            </div>
                            <div class="metric-value">
                                <span class="mode">Change:</span>
                                <span class="${changeClass}">${change}%</span>
                            </div>
                        </div>
                    `;
                }).join('');
        }

        function displayModelMetrics() {
            // Group sessions by model
            const models = {};
            filteredSessions.forEach(session => {
                const model = session.model || 'unknown';
                if (!models[model]) {
                    models[model] = {
                        control: [],
                        mcp: []
                    };
                }
                
                if (session.mode === 'control') {
                    models[model].control.push(session);
                } else if (session.mode === 'mcp') {
                    models[model].mcp.push(session);
                }
            });
            
            // Create metrics per model
            const modelMetricsEl = document.getElementById('modelMetrics');
            modelMetricsEl.innerHTML = '';
            
            for (const [model, data] of Object.entries(models)) {
                // Skip if there's no data for either control or MCP
                if (data.control.length === 0 || data.mcp.length === 0) continue;

                // Calculate task run counts
                const taskCounts = {
                    control: {},
                    mcp: {}
                };
                
                // Count control runs per task
                data.control.forEach(session => {
                    taskCounts.control[session.taskId] = (taskCounts.control[session.taskId] || 0) + 1;
                });
                
                // Count MCP runs per task
                data.mcp.forEach(session => {
                    taskCounts.mcp[session.taskId] = (taskCounts.mcp[session.taskId] || 0) + 1;
                });
                
                const metrics = {
                    'Duration': {
                        control: average(data.control.map(s => s.duration)) / 1000,
                        mcp: average(data.mcp.map(s => s.duration)) / 1000,
                        unit: 'seconds'
                    },
                    'API Calls': {
                        control: average(data.control.map(s => s.apiCalls)),
                        mcp: average(data.mcp.map(s => s.apiCalls)),
                        unit: 'calls'
                    },
                    'Interactions': {
                        control: average(data.control.map(s => s.interactions)),
                        mcp: average(data.mcp.map(s => s.interactions)),
                        unit: 'messages'
                    },
                    'Success Rate': {
                        control: percentage(data.control.filter(s => s.success).length, data.control.length),
                        mcp: percentage(data.mcp.filter(s => s.success).length, data.mcp.length),
                        unit: '%'
                    }
                };
                
                const section = document.createElement('div');
                section.className = 'model-section';
                
                section.innerHTML = `
                    <div class="model-title">Model: ${model}</div>
                    <div class="run-counts-section">
                        <div class="run-counts-title">Task Run Distribution</div>
                        <div class="run-counts-grid">
                            ${[1, 2, 3].map(taskId => `
                                <div class="run-count-card">
                                    <div class="run-count-title">Task ${taskId}</div>
                                    <div class="run-count-values">
                                        <div>Control: ${taskCounts.control[taskId] || 0}</div>
                                        <div>MCP: ${taskCounts.mcp[taskId] || 0}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="model-metrics-grid">
                        ${Object.entries(metrics).map(([title, values]) => {
                            const change = percentageChange(values.mcp, values.control);
                            const changeClass = (title === 'Success Rate' ? 
                                parseFloat(change) > 0 : parseFloat(change) < 0) 
                                ? 'change-positive' : 'change-negative';
                            
                            return `
                                <div class="compact-metric-card">
                                    <div class="compact-metric-title">${title}</div>
                                    <div class="compact-metric-content">
                                        <div class="compact-metric-label">Control:</div>
                                        <div class="compact-metric-value">${values.control.toFixed(1)}${title.includes('Rate') ? '%' : ''}</div>
                                        <div class="compact-metric-label">MCP:</div>
                                        <div class="compact-metric-value">${values.mcp.toFixed(1)}${title.includes('Rate') ? '%' : ''}</div>
                                        <div class="compact-metric-label">Change:</div>
                                        <div class="compact-metric-value ${changeClass}">${change}%</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                modelMetricsEl.appendChild(section);
            }
            
            // Show message if no model metrics to display
            if (modelMetricsEl.children.length === 0) {
                const messageEl = document.createElement('div');
                messageEl.className = 'card';
                messageEl.innerHTML = '<p>No model-specific data available for the selected filters.</p>';
                modelMetricsEl.appendChild(messageEl);
            }
        }

        function displaySessions() {
            const tbody = document.getElementById('sessionsBody');
            
            if (filteredSessions.length === 0) {
                tbody.innerHTML = `<tr><td colspan="10" style="text-align: center;">No data available for the selected filters.</td></tr>`;
                return;
            }
            
            tbody.innerHTML = filteredSessions
                .sort((a, b) => {
                    // Sort by server first, then by client, then by task, then by mode
                    const serverA = a.mcpServer || 'Unknown';
                    const serverB = b.mcpServer || 'Unknown';
                    
                    if (serverA !== serverB) {
                        return serverA.localeCompare(serverB);
                    }
                    
                    const clientA = a.mcpClient || 'Unknown';
                    const clientB = b.mcpClient || 'Unknown';
                    
                    if (clientA !== clientB) {
                        return clientA.localeCompare(clientB);
                    }
                    
                    if (a.taskId === b.taskId) {
                        return a.mode.localeCompare(b.mode);
                    }
                    return a.taskId - b.taskId;
                })
                .map(s => `
                    <tr>
                        <td><strong>${s.mcpServer || 'Unknown'}</strong></td>
                        <td><strong>${s.mcpClient || 'Unknown'}</strong></td>
                        <td>Task ${s.taskId}</td>
                        <td><span class="badge badge-${s.mode}">${s.mode}</span></td>
                        <td><strong>${s.model || 'Unknown'}</strong></td>
                        <td>${(s.duration/1000).toFixed(1)}</td>
                        <td>${s.apiCalls}</td>
                        <td>${s.interactions}</td>
                        <td class="${s.success ? 'success' : 'failure'}">${s.success ? '‚úì' : '‚úó'}</td>
                        <td>${s.notes || '-'}</td>
                    </tr>
                `).join('');
        }

        function initCharts() {
            const textColor = '#001B2D';
            const gridColor = 'rgba(0, 0, 0, 0.1)';
            
            // Create comparison chart (bar chart)
            const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
            if (charts.comparison) charts.comparison.destroy();
            
            charts.comparison = new Chart(comparisonCtx, {
                type: 'bar',
                data: {
                    labels: ['Task 1', 'Task 2', 'Task 3'],
                    datasets: [
                        {
                            label: 'Control',
                            data: [0, 0, 0],
                            backgroundColor: `rgba(18, 28, 45, 0.9)`,
                            borderColor: `rgba(18, 28, 45, 1)`,
                            borderWidth: 2,
                            borderRadius: 4
                        },
                        {
                            label: 'MCP',
                            data: [0, 0, 0],
                            backgroundColor: `rgba(242, 47, 70, 0.9)`,
                            borderColor: `rgba(242, 47, 70, 1)`,
                            borderWidth: 2,
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            grid: {
                                color: gridColor,
                                borderColor: gridColor,
                                tickColor: gridColor
                            },
                            ticks: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: gridColor,
                                borderColor: gridColor,
                                tickColor: gridColor
                            },
                            ticks: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                }
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                },
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Duration Comparison (seconds)',
                            color: textColor,
                            font: {
                                size: 16,
                                weight: '600'
                            },
                            padding: {
                                top: 10,
                                bottom: 20
                            }
                        }
                    }
                }
            });
        }
        
        function updateCharts() {
            if (!charts.comparison) return;
            
            const controlSessions = filteredSessions.filter(s => s.mode === 'control');
            const mcpSessions = filteredSessions.filter(s => s.mode === 'mcp');
            
            if (controlSessions.length === 0 || mcpSessions.length === 0) {
                // Reset chart data if no data available
                updateComparisonChart('duration');
                return;
            }
            
            // Update comparison chart with the currently selected metric
            const activeTab = document.querySelector('.tabs .tab[data-chart].active');
            const activeMetric = activeTab ? activeTab.getAttribute('data-chart') : 'duration';
            updateComparisonChart(activeMetric);
        }
        
        function updateComparisonChart(metric) {
            if (!charts.comparison) return;
            
            // Group sessions by task
            const taskData = {
                '1': { control: [], mcp: [] },
                '2': { control: [], mcp: [] },
                '3': { control: [], mcp: [] }
            };
            
            filteredSessions.forEach(session => {
                const taskId = session.taskId.toString();
                if (taskData[taskId] && session.mode) {
                    taskData[taskId][session.mode].push(session);
                }
            });
            
            // Calculate metrics for each task
            const data = {
                control: [0, 0, 0],
                mcp: [0, 0, 0]
            };
            
            let titleText = '';
            
            switch (metric) {
                case 'duration':
                    titleText = 'Duration Comparison (seconds)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        // Only include sessions with non-null duration
                        const controlDurations = taskData[taskId].control.map(s => s.duration).filter(d => d !== null);
                        const mcpDurations = taskData[taskId].mcp.map(s => s.duration).filter(d => d !== null);
                        data.control[i-1] = average(controlDurations) / 1000;
                        data.mcp[i-1] = average(mcpDurations) / 1000;
                    }
                    break;
                case 'apiCalls':
                    titleText = 'API Calls Comparison (count)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        // Only include sessions with non-null apiCalls
                        const controlCalls = taskData[taskId].control.map(s => s.apiCalls).filter(c => c !== null);
                        const mcpCalls = taskData[taskId].mcp.map(s => s.apiCalls).filter(c => c !== null);
                        data.control[i-1] = average(controlCalls);
                        data.mcp[i-1] = average(mcpCalls);
                    }
                    break;
                case 'interactions':
                    titleText = 'User Interactions Comparison (messages)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        // Only include sessions with non-null interactions
                        const controlInteractions = taskData[taskId].control.map(s => s.interactions).filter(i => i !== null);
                        const mcpInteractions = taskData[taskId].mcp.map(s => s.interactions).filter(i => i !== null);
                        data.control[i-1] = average(controlInteractions);
                        data.mcp[i-1] = average(mcpInteractions);
                    }
                    break;
                case 'success':
                    titleText = 'Success Rate Comparison (%)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        // Include all sessions for success rate calculation
                        data.control[i-1] = percentage(taskData[taskId].control.filter(s => s.success).length, taskData[taskId].control.length);
                        data.mcp[i-1] = percentage(taskData[taskId].mcp.filter(s => s.success).length, taskData[taskId].mcp.length);
                    }
                    break;
            }
            
            // Update chart data
            charts.comparison.data.datasets[0].data = data.control;
            charts.comparison.data.datasets[1].data = data.mcp;
            charts.comparison.options.plugins.title.text = titleText;
            charts.comparison.update();
        }

        function downloadCsv() {
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // Add headers
            csvContent += "MCP Server,MCP Client,Task ID,Mode,Model,Duration (s),API Calls (count),User Interactions (count),Success,Notes\n";
            
            // Add data rows
            filteredSessions.forEach(s => {
                const row = [
                    s.mcpServer || 'Twilio',
                    s.mcpClient || 'Cursor',
                    s.taskId,
                    s.mode,
                    s.model || 'unknown',
                    (s.duration/1000).toFixed(1),
                    s.apiCalls,
                    s.interactions,
                    s.success ? 'Yes' : 'No',
                    (s.notes || '').replace(/,/g, ';') // Replace commas to avoid CSV issues
                ].join(',');
                csvContent += row + "\n";
            });
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "mcp_performance_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function average(values) {
            // Filter out null values before calculating average
            const validValues = values.filter(val => val !== null);
            return validValues.length ? validValues.reduce((sum, val) => sum + val, 0) / validValues.length : 0;
        }

        function percentage(part, total) {
            return total ? (part / total) * 100 : 0;
        }

        function percentageChange(newValue, oldValue) {
            return oldValue ? (((newValue - oldValue) / oldValue) * 100).toFixed(1) : 'N/A';
        }

        // Load data when page loads
        loadData();

        // Add event listeners for task tabs
        document.getElementById('taskTabs').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                // Remove active class from all tabs
                document.querySelectorAll('#taskTabs .tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Add active class to clicked tab
                e.target.classList.add('active');
                
                // Hide all task content
                document.querySelectorAll('.task-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                // Show selected task content
                const taskId = e.target.getAttribute('data-task');
                document.getElementById(`task-${taskId}`).style.display = 'block';
            }
        });

        // Add event listeners for chart tabs
        document.querySelector('.tabs:not(#taskTabs)').addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                // Remove active class from all tabs
                e.target.parentElement.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Add active class to clicked tab
                e.target.classList.add('active');
                
                // Update chart with selected metric
                const metric = e.target.getAttribute('data-chart');
                updateComparisonChart(metric);
            }
        });

        // Add event listeners for filters
        document.getElementById('mcpServerFilter').addEventListener('change', () => {
            filterData();
            displayMetrics();
            displayModelMetrics();
            displaySessions();
            updateCharts();
        });

        document.getElementById('mcpClientFilter').addEventListener('change', () => {
            filterData();
            displayMetrics();
            displayModelMetrics();
            displaySessions();
            updateCharts();
        });

        document.getElementById('modelFilter').addEventListener('change', () => {
            filterData();
            displayMetrics();
            displayModelMetrics();
            displaySessions();
            updateCharts();
        });

        document.getElementById('taskFilter').addEventListener('change', () => {
            filterData();
            displayMetrics();
            displayModelMetrics();
            displaySessions();
            updateCharts();
        });

        document.getElementById('modeFilter').addEventListener('change', () => {
            filterData();
            displayMetrics();
            displayModelMetrics();
            displaySessions();
            updateCharts();
        });

        // Add refresh button functionality
        document.getElementById('refreshBtn').addEventListener('click', () => {
            loadData();
        });

        // Add download button functionality
        document.getElementById('downloadBtn').addEventListener('click', () => {
            downloadCsv();
        });
    </script>
</body>
</html>