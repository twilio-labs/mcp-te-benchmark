<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Context Protocol (MCP) Performance Dashboard</title>
    <style>
        :root {
            /* Twilio primary palette */
            --primary: #F22F46;          /* Twilio red */
            --primary-dark: #D42B3F;     /* Darker shade of Twilio red */
            --primary-light: #F45C6D;    /* Lighter shade of Twilio red */
            --secondary: #121C2D;        /* Ink */
            --secondary-dark: #0A1018;   /* Darker shade of Ink */
            --secondary-light: #1E2D47;  /* Lighter shade of Ink */
            
            /* Twilio secondary colors */
            --sun: #FF7A00;             /* Sun */
            --bright-saffron: #FFCB44;  /* Bright Saffron */
            --sky: #51A9E3;             /* Sky */
            --mint: #6ADDB2;            /* Mint */
            
            /* Twilio grays */
            --gray-50: #F2F4F7;
            --gray-100: #D8DDE6;
            --gray-500: #7D8777;
            --gray-850: #1F2F36;
            
            /* Semantic colors */
            --success: #6ADDB2;          /* Using Mint as success */
            --warning: #FFCB44;          /* Using Bright Saffron as warning */
            --danger: #F22F46;           /* Using Twilio red as danger */
            --light: #FFFFFF;            /* White */
            --dark: #121C2D;             /* Using Ink as dark */
            
            /* Other UI colors */
            --gray: #D8DDE6;             /* Grey-100 */
            --gray-light: #F2F4F7;       /* Grey-50 */
            --gray-dark: #1F2F36;        /* Grey-850 */
            
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --radius: 0.375rem;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--light);
            color: var(--secondary);
            line-height: 1.5;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background-color: var(--secondary);
            color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .header-content {
            flex: 1;
            margin-left: 2rem;
        }

        .logo {
            height: 40px;
            width: auto;
        }

        header h1 {
            color: var(--light);
            margin-bottom: 0.5rem;
            font-size: 1.75rem;
        }

        header p {
            color: var(--gray-100);
            opacity: 0.9;
            font-size: 1rem;
        }

        h1, h2, h3 {
            color: var(--secondary);
            font-weight: 700;
            transition: color 0.3s;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.5rem;
            margin: 1.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
        }

        .card {
            background-color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 4px solid var(--primary);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background-color: var(--light);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            border-left: 4px solid var(--sky);
            transition: transform 0.2s;
        }

        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        .metric-title {
            font-weight: 600;
            color: var(--secondary);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.3s;
        }

        .metric-value {
            font-size: 1.1rem;
            margin: 0.5rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode {
            display: inline-block;
            width: 80px;
            font-weight: 500;
        }

        .metric-unit {
            font-size: 0.85rem;
            color: var(--gray-500);
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .model-section {
            margin-bottom: 2rem;
            background-color: white;
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: background-color 0.3s;
        }

        .model-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--secondary);
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
            transition: color 0.3s;
        }

        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            background-color: white;
            transition: background-color 0.3s;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            transition: background-color 0.3s;
        }

        th {
            background-color: var(--secondary);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:nth-child(even) {
            background-color: var(--gray-light);
        }

        tr:hover {
            background-color: rgba(242, 47, 70, 0.05);
        }

        td {
            border-bottom: 1px solid var(--gray-light);
        }

        .badge {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-control {
            background-color: var(--secondary);
            color: var(--light);
        }

        .badge-mcp {
            background-color: var(--primary);
            color: var(--light);
        }

        .success {
            color: var(--mint);
            font-weight: 600;
        }

        .failure {
            color: var(--danger);
            font-weight: 600;
        }

        .change-positive {
            color: var(--mint);
            font-weight: 600;
        }

        .change-negative {
            color: var(--danger);
            font-weight: 600;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            background-color: var(--primary);
            color: var(--light);
            border: none;
            border-radius: var(--radius);
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            background-color: var(--secondary-light);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--secondary);
            border: 1px solid var(--secondary);
        }

        .btn-outline:hover {
            background-color: var(--secondary);
            color: white;
        }

        .loading {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: var(--gray-dark);
        }

        .spinner {
            border: 3px solid var(--gray-light);
            border-radius: 50%;
            border-top: 3px solid var(--primary);
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .footer {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--gray);
            color: var(--gray-dark);
            text-align: center;
            font-size: 0.9rem;
        }

        /* Filters */
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-label {
            font-weight: 600;
            font-size: 0.9rem;
        }

        select {
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            border: 1px solid var(--gray);
            background-color: white;
            font-family: var(--font-sans);
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(242, 47, 70, 0.2);
        }

        /* Chart styles */
        .chart-container {
            height: 300px;
            margin-bottom: 2rem;
        }

        .chart-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        /* Task tabs */
        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--gray-100);
            gap: 0.5rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: var(--secondary);
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--primary);
            background-color: var(--gray-50);
            border-radius: var(--radius) var(--radius) 0 0;
        }

        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            background-color: var(--gray-50);
        }

        /* Warning Message */
        .card[style*="warning"] {
            border-left: 4px solid var(--warning);
            background-color: rgba(255, 203, 68, 0.1);
        }

        /* Statistics card */
        .stat-card {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-item {
            text-align: center;
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--light), var(--gray-50));
            border-radius: var(--radius);
            border: 1px solid var(--gray-100);
            transition: transform 0.2s;
        }

        .stat-item:hover {
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.75rem;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .metrics,
            .chart-row {
                grid-template-columns: 1fr;
            }
            
            .filters {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .stat-card {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.75rem;
            }
            
            h2 {
                font-size: 1.25rem;
            }
        }
    </style>
    <!-- Include Chart.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <img src="/docs/twilioAlphaLogo.png" alt="Twilio Alpha" class="logo">
            <div class="header-content">
                <h1>Model Context Protocol (MCP) Performance Dashboard</h1>
                <p>Compare performance metrics between Traditional (Control) and MCP implementations</p>
            </div>
        </header>
        
        <div class="actions">
            <button id="refreshBtn" class="btn">
                <span>↻</span> Refresh Data
            </button>
            <button id="downloadBtn" class="btn btn-secondary">
                <span>↓</span> Download CSV
            </button>
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <span>Loading data...</span>
            </div>
        </div>
        
        <div class="filters">
            <div class="filter-group">
                <label class="filter-label" for="mcpServerFilter">MCP Server:</label>
                <select id="mcpServerFilter">
                    <option value="all">All Servers</option>
                    <option value="Twilio" selected>Twilio</option>
                    <!-- Other servers will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="mcpClientFilter">MCP Client:</label>
                <select id="mcpClientFilter">
                    <option value="all">All Clients</option>
                    <option value="Cursor" selected>Cursor</option>
                    <!-- Other clients will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="modelFilter">Model:</label>
                <select id="modelFilter">
                    <option value="all">All Models</option>
                    <!-- Options will be dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="taskFilter">Task:</label>
                <select id="taskFilter">
                    <option value="all">All Tasks</option>
                    <option value="1">Task 1</option>
                    <option value="2">Task 2</option>
                    <option value="3">Task 3</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="filter-label" for="modeFilter">Mode:</label>
                <select id="modeFilter">
                    <option value="all">All Modes</option>
                    <option value="control">Control</option>
                    <option value="mcp">MCP</option>
                </select>
            </div>
        </div>
        
        <!-- Test Approaches -->
        <div class="card">
            <h2>Test Approach</h2>
            <div class="metrics" style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Full-width box -->
                <div class="metric-card" style="width: 100%;">
                    <div class="metric-title">Testing Environment & Methodology</div>
                    <p>Tests are conducted using Cursor IDE in "Yolo" mode, allowing AI agents to execute actions autonomously. Cursor was chosen as the MCP client for its built-in web search and terminal execution capabilities, making it ideal for both control and MCP testing scenarios.</p>
                    <p style="margin-top: 10px">A custom metrics tracking system was implemented since Cursor doesn't expose execution logs. While task duration is automatically tracked, other metrics (API calls, user interactions, and success status) are manually calculated due to limitations in Cursor's logging capabilities.</p>
                    <p style="margin-top: 10px">Each task is performed twice - once using traditional methods and once using MCP. For detailed information about the testing protocol and setup, visit our <a href="https://github.com/nmogil-tw/twilio-mcp-performance" target="_blank" style="color: var(--primary);">GitHub repository</a>.</p>
                </div>
                <!-- Two side-by-side boxes container -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="metric-card">
                        <div class="metric-title">
                            <span class="badge badge-control">Control</span>
                        </div>
                        <p>Traditional method using web search and terminal capabilities to complete API tasks. The Control approach requires manually looking up documentation and writing code from scratch.</p>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">
                            <span class="badge badge-mcp">MCP</span>
                        </div>
                        <p>Model Context Protocol approach that provides AI coding agents with direct access to API functions. MCP enables AI to understand API structure without external documentation.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Task Description -->
        <div class="card">
            <h2>Task Description</h2>
            <div class="tabs" id="taskTabs">
                <div class="tab active" data-task="1">Task 1</div>
                <div class="tab" data-task="2">Task 2</div>
                <div class="tab" data-task="3">Task 3</div>
            </div>
            <div class="task-content" id="task-1">
                <div class="metric-card">
                    <div class="metric-title">Task 1: Purchase a Canadian Phone Number</div>
                    <p>Search for and purchase an available Canadian phone number (preferably with area code 416).</p>
                </div>
            </div>
            <div class="task-content" id="task-2" style="display: none;">
                <div class="metric-card">
                    <div class="metric-title">Task 2: Create a Task Router Activity</div>
                    <p>Create a new Task Router activity named "Bathroom", this already exists so the Agent won't be able to create it.</p>
                </div>
            </div>
            <div class="task-content" id="task-3" style="display: none;">
                <div class="metric-title">Task 3: Create a Queue with Task Filter</div>
                <p>Create a queue with a task filter that prevents routing tasks to workers in the "Bathroom" activity.</p>
            </div>
        </div>
        
        <!-- Warning Message -->
        <div class="card" style="border-left: 4px solid var(--warning); background-color: rgba(236, 201, 75, 0.1);">
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <span style="font-size: 1.5rem;">⚠️</span>
                <h3 style="margin: 0; color: var(--secondary-dark);">Known Issue</h3>
            </div>
            <p style="margin-top: 0.5rem;">There is an open bug in Cursor which restricts MCP use to the "auto" Agent model, preventing us from selecting a specific LLM model. This limitation affects model-specific performance analysis.</p>
        </div>
        
        <!-- Overall Stats -->
        <div class="card">
            <h2>Overall Performance</h2>
            <div class="stat-card">
                <div class="stat-item">
                    <div id="improvementTime" class="stat-value">--%</div>
                    <div class="stat-label">Time Improvement</div>
                </div>
                <div class="stat-item">
                    <div id="improvementCalls" class="stat-value">--%</div>
                    <div class="stat-label">API Calls Reduction</div>
                </div>
                <div class="stat-item">
                    <div id="improvementInteractions" class="stat-value">--%</div>
                    <div class="stat-label">Interaction Reduction</div>
                </div>
                <div class="stat-item">
                    <div id="improvementSuccess" class="stat-value">--%</div>
                    <div class="stat-label">Success Rate Improvement</div>
                </div>
            </div>
            <div id="summary" class="metrics"></div>
        </div>
        
        <!-- Charts -->
        <div class="card">
            <h2>Performance Charts</h2>
            <div class="tabs">
                <div class="tab active" data-chart="duration">Duration</div>
                <div class="tab" data-chart="apiCalls">API Calls</div>
                <div class="tab" data-chart="interactions">Interactions</div>
                <div class="tab" data-chart="success">Success Rate</div>
            </div>
            <div class="chart-row">
                <div class="chart-container">
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="modelMetrics"></div>
        
        <div class="card">
            <h2>Detailed Results</h2>
            <div class="table-container">
                <table id="sessionsTable">
                    <thead>
                        <tr>
                            <th>MCP Server</th>
                            <th>MCP Client</th>
                            <th>Task</th>
                            <th>Mode</th>
                            <th>Model</th>
                            <th>Duration (s)</th>
                            <th>API Calls (count)</th>
                            <th>User Interactions (count)</th>
                            <th>Success</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody id="sessionsBody"></tbody>
                </table>
            </div>
        </div>
        
        <div class="footer">
            <p>Model Context Protocol Performance Dashboard</p>
            <p>Last updated: <span id="lastUpdated">-</span></p>
        </div>
    </div>

    <script>
        // Global data store
        let allSessions = [];
        let filteredSessions = [];
        let charts = {};
        
        async function loadData() {
            try {
                const response = await fetch('/metrics/summary.json');
                const data = await response.json();
                
                // Store the data globally
                allSessions = data;
                
                // Update last updated time
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                
                // Populate MCP server filter
                const mcpServers = [...new Set(data.map(s => s.mcpServer || 'Twilio'))];
                const mcpServerFilter = document.getElementById('mcpServerFilter');
                
                // Clear existing options except the first one
                while (mcpServerFilter.options.length > 1) {
                    mcpServerFilter.remove(1);
                }
                
                // Add server options
                mcpServers.forEach(server => {
                    const option = document.createElement('option');
                    option.value = server;
                    option.textContent = server;
                    // Select Twilio by default
                    if (server === 'Twilio') {
                        option.selected = true;
                    }
                    mcpServerFilter.appendChild(option);
                });
                
                // Populate MCP client filter
                const mcpClients = [...new Set(data.map(s => s.mcpClient || 'Cursor'))];
                const mcpClientFilter = document.getElementById('mcpClientFilter');
                
                // Clear existing options except the first one
                while (mcpClientFilter.options.length > 1) {
                    mcpClientFilter.remove(1);
                }
                
                // Add client options
                mcpClients.forEach(client => {
                    const option = document.createElement('option');
                    option.value = client;
                    option.textContent = client;
                    // Select Cursor by default
                    if (client === 'Cursor') {
                        option.selected = true;
                    }
                    mcpClientFilter.appendChild(option);
                });
                
                // Populate model filter
                const models = [...new Set(data.map(s => s.model || 'unknown'))];
                const modelFilter = document.getElementById('modelFilter');
                
                // Clear existing options except the first one
                while (modelFilter.options.length > 1) {
                    modelFilter.remove(1);
                }
                
                // Add model options
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelFilter.appendChild(option);
                });
                
                // Apply filters and update UI
                filterData();
                displayMetrics();
                displayModelMetrics();
                displaySessions();
                initCharts();
                updateCharts();
                
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Failed to load data. Please check if the metrics server is running.');
            }
        }
        
        function filterData() {
            const mcpServerFilter = document.getElementById('mcpServerFilter').value;
            const mcpClientFilter = document.getElementById('mcpClientFilter').value;
            const modelFilter = document.getElementById('modelFilter').value;
            const taskFilter = document.getElementById('taskFilter').value;
            const modeFilter = document.getElementById('modeFilter').value;
            
            filteredSessions = allSessions.filter(session => {
                const matchesMcpServer = mcpServerFilter === 'all' || (session.mcpServer || 'Twilio') === mcpServerFilter;
                const matchesMcpClient = mcpClientFilter === 'all' || (session.mcpClient || 'Cursor') === mcpClientFilter;
                const matchesModel = modelFilter === 'all' || session.model === modelFilter || (!session.model && modelFilter === 'unknown');
                const matchesTask = taskFilter === 'all' || session.taskId.toString() === taskFilter;
                const matchesMode = modeFilter === 'all' || session.mode === modeFilter;
                
                return matchesMcpServer && matchesMcpClient && matchesModel && matchesTask && matchesMode;
            });
        }

        function displayMetrics() {
            const controlSessions = filteredSessions.filter(s => s.mode === 'control');
            const mcpSessions = filteredSessions.filter(s => s.mode === 'mcp');
            
            if (controlSessions.length === 0 || mcpSessions.length === 0) {
                document.getElementById('summary').innerHTML = '<p>No data available for the selected filters.</p>';
                return;
            }
            
            const metrics = {
                'Average Duration': {
                    control: average(controlSessions.map(s => s.duration)) / 1000, // Convert to seconds
                    mcp: average(mcpSessions.map(s => s.duration)) / 1000,
                    unit: 'seconds'
                },
                'Average API Calls': {
                    control: average(controlSessions.map(s => s.apiCalls)),
                    mcp: average(mcpSessions.map(s => s.apiCalls)),
                    unit: 'calls'
                },
                'Average Interactions': {
                    control: average(controlSessions.map(s => s.interactions)),
                    mcp: average(mcpSessions.map(s => s.interactions)),
                    unit: 'messages'
                },
                'Success Rate': {
                    control: percentage(controlSessions.filter(s => s.success).length, controlSessions.length),
                    mcp: percentage(mcpSessions.filter(s => s.success).length, mcpSessions.length),
                    unit: '%'
                }
            };
            
            // Update improvement stats
            const improvements = {
                time: percentageChange(metrics['Average Duration'].mcp, metrics['Average Duration'].control),
                calls: percentageChange(metrics['Average API Calls'].mcp, metrics['Average API Calls'].control),
                interactions: percentageChange(metrics['Average Interactions'].mcp, metrics['Average Interactions'].control),
                success: percentageChange(metrics['Success Rate'].mcp, metrics['Success Rate'].control)
            };
            
            document.getElementById('improvementTime').textContent = `${-parseFloat(improvements.time)}%`;
            document.getElementById('improvementCalls').textContent = `${-parseFloat(improvements.calls)}%`;
            document.getElementById('improvementInteractions').textContent = `${-parseFloat(improvements.interactions)}%`;
            document.getElementById('improvementSuccess').textContent = `${improvements.success}%`;

            const summaryEl = document.getElementById('summary');
            summaryEl.innerHTML = Object.entries(metrics)
                .map(([title, values]) => {
                    const change = percentageChange(values.mcp, values.control);
                    const changeClass = (title === 'Success Rate' ? 
                        parseFloat(change) > 0 : parseFloat(change) < 0) 
                        ? 'change-positive' : 'change-negative';
                    
                    return `
                        <div class="metric-card">
                            <div class="metric-title">${title}</div>
                            <div class="metric-unit">Measured in ${values.unit}</div>
                            <div class="metric-value">
                                <span class="mode">Control:</span>
                                <span>${values.control.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                            </div>
                            <div class="metric-value">
                                <span class="mode">MCP:</span>
                                <span>${values.mcp.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                            </div>
                            <div class="metric-value">
                                <span class="mode">Change:</span>
                                <span class="${changeClass}">${change}%</span>
                            </div>
                        </div>
                    `;
                }).join('');
        }

        function displayModelMetrics() {
            // Group sessions by model
            const models = {};
            filteredSessions.forEach(session => {
                const model = session.model || 'unknown';
                if (!models[model]) {
                    models[model] = {
                        control: [],
                        mcp: []
                    };
                }
                
                if (session.mode === 'control') {
                    models[model].control.push(session);
                } else if (session.mode === 'mcp') {
                    models[model].mcp.push(session);
                }
            });
            
            // Create metrics per model
            const modelMetricsEl = document.getElementById('modelMetrics');
            modelMetricsEl.innerHTML = '';
            
            for (const [model, data] of Object.entries(models)) {
                // Skip if there's no data for either control or MCP
                if (data.control.length === 0 || data.mcp.length === 0) continue;
                
                const metrics = {
                    'Duration': {
                        control: average(data.control.map(s => s.duration)) / 1000,
                        mcp: average(data.mcp.map(s => s.duration)) / 1000,
                        unit: 'seconds'
                    },
                    'API Calls': {
                        control: average(data.control.map(s => s.apiCalls)),
                        mcp: average(data.mcp.map(s => s.apiCalls)),
                        unit: 'calls'
                    },
                    'Interactions': {
                        control: average(data.control.map(s => s.interactions)),
                        mcp: average(data.mcp.map(s => s.interactions)),
                        unit: 'messages'
                    },
                    'Success Rate': {
                        control: percentage(data.control.filter(s => s.success).length, data.control.length),
                        mcp: percentage(data.mcp.filter(s => s.success).length, data.mcp.length),
                        unit: '%'
                    }
                };
                
                const section = document.createElement('div');
                section.className = 'model-section';
                
                section.innerHTML = `
                    <div class="model-title">Model: ${model}</div>
                    <div class="metrics">
                        ${Object.entries(metrics).map(([title, values]) => {
                            const change = percentageChange(values.mcp, values.control);
                            const changeClass = (title === 'Success Rate' ? 
                                parseFloat(change) > 0 : parseFloat(change) < 0) 
                                ? 'change-positive' : 'change-negative';
                            
                            return `
                                <div class="metric-card">
                                    <div class="metric-title">${title}</div>
                                    <div class="metric-unit">Measured in ${values.unit}</div>
                                    <div class="metric-value">
                                        <span class="mode">Control:</span>
                                        <span>${values.control.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                                    </div>
                                    <div class="metric-value">
                                        <span class="mode">MCP:</span>
                                        <span>${values.mcp.toFixed(1)}${title.includes('Rate') ? '%' : ''}</span>
                                    </div>
                                    <div class="metric-value">
                                        <span class="mode">Change:</span>
                                        <span class="${changeClass}">${change}%</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                modelMetricsEl.appendChild(section);
            }
            
            // Show message if no model metrics to display
            if (modelMetricsEl.children.length === 0) {
                const messageEl = document.createElement('div');
                messageEl.className = 'card';
                messageEl.innerHTML = '<p>No model-specific data available for the selected filters.</p>';
                modelMetricsEl.appendChild(messageEl);
            }
        }

        function displaySessions() {
            const tbody = document.getElementById('sessionsBody');
            
            if (filteredSessions.length === 0) {
                tbody.innerHTML = `<tr><td colspan="10" style="text-align: center;">No data available for the selected filters.</td></tr>`;
                return;
            }
            
            tbody.innerHTML = filteredSessions
                .sort((a, b) => {
                    // Sort by server first, then by client, then by task, then by mode
                    const serverA = a.mcpServer || 'Twilio';
                    const serverB = b.mcpServer || 'Twilio';
                    
                    if (serverA !== serverB) {
                        return serverA.localeCompare(serverB);
                    }
                    
                    const clientA = a.mcpClient || 'Cursor';
                    const clientB = b.mcpClient || 'Cursor';
                    
                    if (clientA !== clientB) {
                        return clientA.localeCompare(clientB);
                    }
                    
                    if (a.taskId === b.taskId) {
                        return a.mode.localeCompare(b.mode);
                    }
                    return a.taskId - b.taskId;
                })
                .map(s => `
                    <tr>
                        <td>${s.mcpServer || 'Twilio'}</td>
                        <td>${s.mcpClient || 'Cursor'}</td>
                        <td>Task ${s.taskId}</td>
                        <td><span class="badge badge-${s.mode}">${s.mode}</span></td>
                        <td>${s.model || 'unknown'}</td>
                        <td>${(s.duration/1000).toFixed(1)}</td>
                        <td>${s.apiCalls}</td>
                        <td>${s.interactions}</td>
                        <td class="${s.success ? 'success' : 'failure'}">${s.success ? '✓' : '✗'}</td>
                        <td>${s.notes || '-'}</td>
                    </tr>
                `).join('');
        }

        function initCharts() {
            const textColor = '#001B2D';
            const gridColor = 'rgba(0, 0, 0, 0.1)';
            
            // Create comparison chart (bar chart)
            const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
            if (charts.comparison) charts.comparison.destroy();
            
            charts.comparison = new Chart(comparisonCtx, {
                type: 'bar',
                data: {
                    labels: ['Task 1', 'Task 2', 'Task 3'],
                    datasets: [
                        {
                            label: 'Control',
                            data: [0, 0, 0],
                            backgroundColor: `rgba(18, 28, 45, 0.9)`,
                            borderColor: `rgba(18, 28, 45, 1)`,
                            borderWidth: 2,
                            borderRadius: 4
                        },
                        {
                            label: 'MCP',
                            data: [0, 0, 0],
                            backgroundColor: `rgba(242, 47, 70, 0.9)`,
                            borderColor: `rgba(242, 47, 70, 1)`,
                            borderWidth: 2,
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            grid: {
                                color: gridColor,
                                borderColor: gridColor,
                                tickColor: gridColor
                            },
                            ticks: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: gridColor,
                                borderColor: gridColor,
                                tickColor: gridColor
                            },
                            ticks: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                }
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: textColor,
                                font: {
                                    weight: '600'
                                },
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Duration Comparison (seconds)',
                            color: textColor,
                            font: {
                                size: 16,
                                weight: '600'
                            },
                            padding: {
                                top: 10,
                                bottom: 20
                            }
                        }
                    }
                }
            });
        }
        
        function updateCharts() {
            if (!charts.comparison) return;
            
            const controlSessions = filteredSessions.filter(s => s.mode === 'control');
            const mcpSessions = filteredSessions.filter(s => s.mode === 'mcp');
            
            if (controlSessions.length === 0 || mcpSessions.length === 0) {
                // Reset chart data if no data available
                updateComparisonChart('duration');
                return;
            }
            
            // Update comparison chart with the currently selected metric
            const activeTab = document.querySelector('.tabs .tab[data-chart].active');
            const activeMetric = activeTab ? activeTab.getAttribute('data-chart') : 'duration';
            updateComparisonChart(activeMetric);
        }
        
        function updateComparisonChart(metric) {
            if (!charts.comparison) return;
            
            // Group sessions by task
            const taskData = {
                '1': { control: [], mcp: [] },
                '2': { control: [], mcp: [] },
                '3': { control: [], mcp: [] }
            };
            
            filteredSessions.forEach(session => {
                const taskId = session.taskId.toString();
                if (taskData[taskId] && session.mode) {
                    taskData[taskId][session.mode].push(session);
                }
            });
            
            // Calculate metrics for each task
            const data = {
                control: [0, 0, 0],
                mcp: [0, 0, 0]
            };
            
            let titleText = '';
            
            switch (metric) {
                case 'duration':
                    titleText = 'Duration Comparison (seconds)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        data.control[i-1] = average(taskData[taskId].control.map(s => s.duration)) / 1000;
                        data.mcp[i-1] = average(taskData[taskId].mcp.map(s => s.duration)) / 1000;
                    }
                    break;
                case 'apiCalls':
                    titleText = 'API Calls Comparison (count)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        data.control[i-1] = average(taskData[taskId].control.map(s => s.apiCalls));
                        data.mcp[i-1] = average(taskData[taskId].mcp.map(s => s.apiCalls));
                    }
                    break;
                case 'interactions':
                    titleText = 'User Interactions Comparison (messages)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        data.control[i-1] = average(taskData[taskId].control.map(s => s.interactions));
                        data.mcp[i-1] = average(taskData[taskId].mcp.map(s => s.interactions));
                    }
                    break;
                case 'success':
                    titleText = 'Success Rate Comparison (%)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        data.control[i-1] = percentage(taskData[taskId].control.filter(s => s.success).length, taskData[taskId].control.length);
                        data.mcp[i-1] = percentage(taskData[taskId].mcp.filter(s => s.success).length, taskData[taskId].mcp.length);
                    }
                    break;
                default:
                    titleText = 'Duration Comparison (seconds)';
                    for (let i = 1; i <= 3; i++) {
                        const taskId = i.toString();
                        data.control[i-1] = average(taskData[taskId].control.map(s => s.duration)) / 1000;
                        data.mcp[i-1] = average(taskData[taskId].mcp.map(s => s.duration)) / 1000;
                    }
                    break;
            }
            
            // Update chart data
            charts.comparison.data.datasets[0].data = data.control;
            charts.comparison.data.datasets[1].data = data.mcp;
            charts.comparison.options.plugins.title.text = titleText;
            charts.comparison.update();
        }

        function downloadCsv() {
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // Add headers
            csvContent += "MCP Server,MCP Client,Task ID,Mode,Model,Duration (s),API Calls (count),User Interactions (count),Success,Notes\n";
            
            // Add data rows
            filteredSessions.forEach(s => {
                const row = [
                    s.mcpServer || 'Twilio',
                    s.mcpClient || 'Cursor',
                    s.taskId,
                    s.mode,
                    s.model || 'unknown',
                    (s.duration/1000).toFixed(1),
                    s.apiCalls,
                    s.interactions,
                    s.success ? 'Yes' : 'No',
                    (s.notes || '').replace(/,/g, ';') // Replace commas to avoid CSV issues
                ].join(',');
                csvContent += row + "\n";
            });
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "mcp_performance_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function average(values) {
            return values.length ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
        }

        function percentage(part, total) {
            return total ? (part / total) * 100 : 0;
        }

        function percentageChange(newValue, oldValue) {
            return oldValue ? (((newValue - oldValue) / oldValue) * 100).toFixed(1) : 'N/A';
        }

        // Load data when page loads
        loadData();
    </script>
</body>
</html>